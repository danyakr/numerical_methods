from math import sin, cos, ceil, sqrt


def integral_value():
    """ Функция запрашивает у пользователя нижний и верхний предел интегрирования
    и количество разбиений

    """
    a = float(input('Введите нижний предел интегрирования:'))
    b = float(input('Введите верхний предел интегрирования:'))
    n = int(input('Введите количество разбиений:'))
    return a, b, n


def integral_value_rem():
    """ Функция запрашивает у пользователя нижний и верхний предел интегрирования
    и точность вычислений

    """
    a = float(input('Введите нижний предел интегрирования:'))
    b = float(input('Введите верхний предел интегрирования:'))
    e = float(input('Введите точность вычислений: '))
    return a, b, e


def integral_value_extend():
    """ Функция запрашивает у пользователя точность вычислений """

    e = float(input('Введите точность вычислений:'))
    return e


def integral_left(a, b, n):
    """ Функция вычисляет приближенное значение определенного интеграла
    методом прямоугольников левых частей

    Для примера берется подынтегральная функция вида: cos(x ** 2 + 0.6) / (1.2 + sin(0.7 * x + 0.2))
    """
    h = (b - a) / n

    x = a
    s = 0
    while x <= (b - h):
        s = s + (cos(x ** 2 + 0.6) / (1.2 + sin(0.7 * x + 0.2)))
        x = x + h

    print(f'\nИнтеграл равен: {h * s}')


def integral_right(a, b, n):
    """ Функция вычисляет приближенное значение определенного интеграла
    методом прямоугольников правых частей

    Для примера берется подынтегральная функция вида: cos(x ** 2 + 0.6) / (1.2 + sin(0.7 * x + 0.2))
    """
    h = (b - a) / n

    x = a + h
    s = 0
    while x <= b:
        s = s + (cos(x ** 2 + 0.6) / (1.2 + sin(0.7 * x + 0.2)))
        x = x + h

    print(f'\nИнтеграл равен: {h * s}')


def integral_trap(a, b, n):
    """ Функция вычисляет приближенное значение определенного интеграла
    методом трапеций

    Для примера берется подынтегральная функция вида: cos(x ** 2 + 0.6) / (1.2 + sin(0.7 * x + 0.2))
    """
    h = (b - a) / n

    f0 = cos(a ** 2 + 0.6) / (1.2 + sin(0.7 * a + 0.2))
    fn = cos(b ** 2 + 0.6) / (1.2 + sin(0.7 * b + 0.2))

    x = a + h
    s = 0
    while x <= (b - h):
        s = s + (cos(x ** 2 + 0.6) / (1.2 + sin(0.7 * x + 0.2)))
        x = x + h

    print(f'\nИнтеграл равен: {h * ((f0 + fn) / 2 + s)}')


def integral_simp(a, b, n):
    """ Функция вычисляет приближенное значение определенного интеграла
    методом парабол(Симпсона)

    Для примера берется подынтегральная функция вида: cos(x ** 2 + 0.6) / (1.2 + sin(0.7 * x + 0.2))
    """

    h = (b - a) / n
    f0 = cos(a ** 2 + 0.6) / (1.2 + sin(0.7 * a + 0.2))
    fn = cos(b ** 2 + 0.6) / (1.2 + sin(0.7 * b + 0.2))

    x = a + h
    s1 = 0
    while x <= (b - h):
        s1 = s1 + (cos(x ** 2 + 0.6) / (1.2 + sin(0.7 * x + 0.2)))
        x = x + 2 * h

    x = a + 2 * h
    s2 = 0
    while x <= (b - 2 * h):
        s2 = s2 + (cos(x ** 2 + 0.6) / (1.2 + sin(0.7 * x + 0.2)))
        x = x + 2 * h

    print(f'\nИнтеграл равен: {(h / 3) * ((f0 + fn) + 2 * s2 + 4 * s1)}')


def integral_left_rem(a, b, n):
    """ Функция вычисляет приближенное значение определенного интеграла
    методом прямоугольников левых частей

    Функция используется в связке с calc_remainder_term(),
    где максимум производной взят для 1 / sqrt(x + 2) с пределами 2 и 7

    Для примера берется подынтегральная функция вида: 1 / sqrt(x + 2)
    """
    h = (b - a) / n

    x = a
    s = 0
    while x <= (b - h):
        s = s + (1 / sqrt(x + 2))
        x = x + h

    return h * s


def calc_remainder_term(a, b, e):
    """ Функция вычисляет остаточный член

    Остаточный член вычисляется для дальнейщего использования в
    методе прямоугольников левых частей.

    В примере рассматривается подынтегральная функция 1 / sqrt(x + 2)
    """
    while True:
        ch = input('1. Ввести модуль максимума прозводной подынтегральной функции (m)\n'
                   '2. Пример работы для  a = 2, b = 7, e = 0.1, m = 0.0625 (нажмите 1 или 2)? ')
        if ch == '1':
            m = float(input('Введите модуль максимума прозводной подынтегральной функции: '))
            break
        elif ch == '2':
            a = 2
            b = 7
            e = 0.1
            m = 1 / 16
            break
        else:
            print('Выберите 1 или 2')
            continue

    n = ceil((b - a) ** 2 / (2 * e) * m)
    return n


def determine_precision_digits(e):
    """Функция вычисляет количество значащих цифр исходя из заданной точности"""

    precision = 0
    while e < 1:
        e *= 10
        precision += 1

    return precision


def integral_left_h(a, b, h):
    """Функция вычисления интеграла методом левых частей

    Передается шаг в отличие от функции integral_left для использования в функции
    double_counter с переменным шагом.

    Функция принимает верхний и нижний пределы интегрирования
    и шаг, который меняется в алгоритме двойного пересчета
    """
    x = a
    s = 0

    while x <= b - h:
        s += cos(x ** 2 + 0.6) / (1.2 + sin(0.7 * x + 0.2))
        x += h

    return h * s


def double_counter(a, b, n, precision):
    """Функция вычисляет приближенное значение определенного интеграла методом двойного пересчета"""

    e = precision
    h = (b - a) / n
    in_value = 0
    i2n = integral_left_h(a, b, h)
    r = abs(i2n - in_value)
    in_value = i2n
    h /= 2

    while r > e:
        i2n = integral_left_h(a, b, h)
        r = abs(i2n - in_value)
        in_value = i2n
        h /= 2

    print(f'\nИнтеграл равен: {round(i2n, determine_precision_digits(e))}')
    print(f'Шаг равен: {h * 2}')


def integral_value_mult():
    """ Функция запрашивает у пользователя нижний и верхний предел интегрирования
    и шаг интегрирования по оси x и y

    """
    a = float(input("Введите нижний предел интегрирования по оси x: "))
    b = float(input("Введите верхний предел интегрирования по оси x: "))
    c = float(input("Введите нижний предел интегрирования по оси y: "))
    d = float(input("Введите верхний предел интегрирования по оси y: "))
    dx = float(input("Введите шаг интегрирования по оси x: "))
    dy = float(input("Введите шаг интегрирования по оси y: "))

    return a, b, c, d, dx, dy


def multiple_integral(a, b, c, d, dx, dy):
    """Функция вычисляет приближенное значение кратных интегралов"""

    integral_sum = 0.0
    x = a
    while x < b:
        y = c
        while y < d:
            integral_sum += (x**2 + y**2) * dx * dy
            y += dy
        x += dx
    print(f'\nИнтеграл равен: {integral_sum}')
